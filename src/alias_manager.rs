use crate::domain::{AppType, Application};
use crate::launcher::Launcher;
use crate::{conf::Conf, tools::get_main_dir};

use anyhow::Result;
use std::path::{PathBuf, Path};
use std::fs::{write, File, OpenOptions, read_to_string};
use std::io::Write;
use std::collections::HashMap;

fn get_alias_file_path() -> PathBuf {
    let mut path = PathBuf::new();
    path.push(get_main_dir());
    path.push("aliases"); 
    path
}

fn is_init(conf: Conf) -> bool {
    let path = conf.alias_path;
    if !Path::new(&path).exists() {
        return false;
    }
    let content = read_to_string(path).expect("Couldn't read user file");
    let alias_path = get_alias_file_path();
    let magic_formula = format!("source {}", alias_path.to_str().unwrap());
    content.contains(&magic_formula)
}

fn init(conf: Conf) -> Result<()> {
    if is_init(conf.clone()) {
        return Ok(());
    }

    let alias_path = get_alias_file_path();

    if !alias_path.exists() {
        File::create(alias_path.clone())?;
    }

    let alias_path_str = alias_path.to_str().unwrap();

    let magic_formula = format!("
# auto generated by Coolauncher to link alias file
if [ -f {} ]; then
    source {}
fi
###
", alias_path_str, alias_path_str);

    let mut file = OpenOptions::new()
        .append(true)
        .open(conf.alias_path.clone())?;

    writeln!(file, "{magic_formula}")?;

    Ok(())
}

pub fn alias_exists(alias: String) -> bool {
    let mut res = false;
    for line in read_to_string(get_alias_file_path()).unwrap().lines() {
        if !line.starts_with("#") {
            let mut split = line.split("=");
            if split.next().unwrap() == alias {
                res = true;
            }
        }
    }
    res
}

fn reset_aliases() -> Result<()> {
    File::create(get_alias_file_path())?;
    Ok(())
}

fn add_alias(alias_name: String, command_line: String, conf: Conf) -> Result<()> {
    init(conf.clone())?;
    
    let mut file = OpenOptions::new()
        .append(true)
        .open(get_alias_file_path())?;

    writeln!(file, "alias {alias_name}=\"{command_line}\"")?;
    Ok(())
}

fn remove_alias(alias_name: String, conf: Conf) -> Result<()> {
    init(conf.clone())?;
    
    let alias_path = get_alias_file_path();
    let mut new_content = String::default();

    for line in read_to_string(alias_path.clone()).unwrap().lines() {
        let mut split = line.split("=");
        if split.next().unwrap() != alias_name {
            new_content += format!("{line}\n").as_str();
        }
    }

    write(alias_path, new_content)?;
    Ok(())
}

impl Application {
    pub fn get_command_string(&self, conf: Conf) -> String {
        match self.app_type.clone() {
            AppType::Custom => self.command.as_ref().unwrap().get_string(),
            AppType::Wine => self.wine_command.as_ref().unwrap().get_string(conf),
        }
    }

    pub fn create_alias(&mut self, alias: String, conf: Conf) -> Result<()> {
        self.alias.push(alias.clone());
        add_alias(alias.clone(), self.get_command_string(conf.clone()), conf.clone())
    }

    pub fn delete_alias(&mut self, alias: String, conf: Conf) -> Result<()> {
        self.alias.retain(|c_alias| c_alias != &alias);
        remove_alias(alias, conf.clone())
    }
}

impl Launcher {
    pub fn alias_file_security(&self) -> Result<()> {
        if self.conf.clone().is_alias_path_default() {
            return Ok(());
        }

        let mut aliases: HashMap<String, String> = HashMap::default();
        for app in self.apps.clone() {
            for alias in app.clone().alias {
                aliases.insert(alias.clone(), app.get_command_string(self.conf.clone()));
            }
        }
        reset_aliases()?;
        for (alias, command) in aliases {
            add_alias(alias, command, self.conf.clone())?;
        }
        Ok(())
    }
}